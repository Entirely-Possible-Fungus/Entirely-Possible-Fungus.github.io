{
    "missions": {
        "columns": {
            "id": "INT PRIMARY KEY",
            "title": "STRING",
            "description": "STRING",
            "hint": "STRING",
            "difficulty": "INT",
            "points": "INT",
            "timeLimit": "INT",
            "timerEnabled": "BOOLEAN",
            "successMessage": "STRING",
            "dbAlias": "STRING",
            "validationCriteria": "JSON",
            "mapDetails": "JSON",
            "nextMissionId": "INT"
        },
        "data": [
            {
                "id": 0,
                "title": "Tutorial: Mounting Databases",
                "description": "Hello Agent, before heading down to earth, lets first learn how to use the SQL systems. Databases are organized collections of structured information or data that can be easily accessed, managed, and updated. <br><br>To use a database, first we need to mount it.</p><ol><li>Click the <strong>DB REGISTRY</strong> button at the top of the screen</li><li>In the registry, find and click the <strong>MOUNT</strong> button next to the <strong>mission_control</strong> database</li><li>Close the <strong>DB Registry</strong> panel by clicking the <span style=\"color:red\">✕</span></li></ol><p><strong>This will mount the missions database so you can access it.</strong>\n\nOnce mounted, you'll be able to complete this mission and proceed to the next where we'll learn how to run SQL queries.<br> If you ever get stuck press hint for a tiny bit of help or solution for the answer; currently there are no penalties, so just have fun.</p>",
                "hint": "Click the DB REGISTRY button, find mission_control, click MOUNT, then close the registry panel.",
                "solution": "Click the DB REGISTRY button, find mission_control, click MOUNT, then close the registry panel.",
                "difficulty": 1,
                "points": 25,
                "timeLimit": 300,
                "timerEnabled": false,
                "successMessage": "Excellent! You've mounted your first database. Now you can access the mission_control database to see what we have available. Click the green button below to continue on.",
                "dbAlias": "mission_control",
                "validationCriteria": {
                    "databaseMounted": true,
                    "requiredDatabase": "mission_control"
                },
                "mapDetails": {
                    "showOnMap": false
                },
                "nextMissionId": 1
            },
            {
                "id": 1,
                "title": "Tutorial: First Query",
                "description": "Now that you've mounted the mission_control database, let's run your first SQL query.<br><br>\n\n<strong>The SQL Console:</strong> This is where you'll write and execute SQL queries\n\n<strong>Try running your first query:</strong>\n\n<code class='pixel-inline-code'>SELECT * FROM missions;</code>\n\n<strong>SQL Explanation:</strong>\n<ul>\n<li><code>SELECT *</code> - Retrieves all columns from the table (the asterisk is a wildcard meaning \"select everything\")</li>\n<li><code>FROM missions</code> - Specifies which table to get data from</li>\n<li><code>;</code> - Marks the end of the SQL statement</li>\n</ul>\n\nThis will show you all the available missions in the database. The results will appear in the Results Area below.",
                "hint": "Type <code>SELECT * FROM missions;</code> in the SQL console and click Execute to see all the missions.",
                "solution": "SELECT * FROM missions;",
                "difficulty": 1,
                "points": 25,
                "timeLimit": 300,
                "timerEnabled": false,
                "successMessage": "Great job! You've run your first SQL query and can now see all available missions in the database.",
                "dbAlias": "mission_control",
                "validationCriteria": {
                    "expectedRows": 15
                    
                },
                "mapDetails": {
                    "showOnMap": false
                },
                "nextMissionId": 2
            },
            {
                "id": 2,
                "title": "Cosmic Cartography: Calibration Scan (SELECT, FROM, WHERE, LIMIT)",
                "description": "Agent, our long-range sensors require calibration using a targeted scan. We must begin our journey towards the Sol system by sifting through initial data.<br><br><strong>Part 1: Understanding SQL Filters</strong><br>In this mission, we'll learn how to filter data with the <code>WHERE</code> clause and limit results with <code>LIMIT</code>.<br><ul><li>The <code>WHERE</code> clause lets you filter rows based on specific conditions</li><li>The <code>LIMIT</code> clause controls how many rows are returned</li></ul><br><strong>Step-by-Step Instructions:</strong><br>1. Mount the <code>deep_space_catalog</code> database using the DB REGISTRY button.<br>2. Write a query to select specific columns from the <code>DeepSpaceObjects</code> table:<br><code>SELECT object_name, object_type, distance_ly<br>FROM DeepSpaceObjects<br>WHERE star_system = 'Xylos Sector'<br>LIMIT 5;</code><br><br>This query does the following:<ul><li>Selects only the <code>object_name</code>, <code>object_type</code>, and <code>distance_ly</code> columns</li><li>Filters to show only objects in the 'Xylos Sector'</li><li>Limits the results to just 5 rows</li></ul><br><strong>Question:</strong> From your 5-entry scan of the Xylos Sector, what is the <code>object_name</code> of the <strong>third</strong> object listed in the results? You will need to type its name into the answer field.",
                "hint": "Mount <code>deep_space_catalog</code>. Run the query: <code>SELECT object_name, object_type, distance_ly FROM DeepSpaceObjects WHERE star_system = 'Xylos Sector' LIMIT 5;</code> Then identify the third object name from the results and type it in.",
                "solution": "SELECT object_name, object_type, distance_ly FROM DeepSpaceObjects WHERE star_system = 'Xylos Sector' LIMIT 5;",
                "difficulty": 1,
                "points": 50,
                "timeLimit": 300,
                "timerEnabled": false,
                "successMessage": "Calibration successful, Agent! Identifying 'Xylos Gamma' confirms sensor accuracy. This targeted data retrieval is key. Every accurate query refines our path to Earth.",
                "dbAlias": "deep_space_catalog",
                "validationCriteria": {
                    "requiredDatabase": "deep_space_catalog",
                    "answerToQuestion": "Xylos Gamma"
                },
                "mapDetails": {
                    "showOnMap": false
                },
                "nextMissionId": 3
            },
            {
                "id": 3,
                "title": "Signal Triangulation: Potential Havens? (AND, OR)",
                "description": "With sensors calibrated, we're searching for potential havens or resource-rich locations in the <code>deep_space_catalog</code>. Our science team believes such locations are likely to be <code>'Planet'</code> type objects that are either flagged as <code>is_habitable_candidate = TRUE</code> <strong>OR</strong> have a <code>spectral_signature</code> of <code>'Water'</code>.<br><br><strong>Part 1: Understanding Complex Filters</strong><br>In this mission, we'll learn how to create more complex filters using logical operators:<br><ul><li><code>AND</code> - Both conditions must be true</li><li><code>OR</code> - At least one condition must be true</li><li>Parentheses <code>()</code> - Group conditions together, just like in math</li></ul><br><strong>Part 2: Using COUNT Function</strong><br>The <code>COUNT()</code> function counts the number of rows that match your criteria. When combined with <code>DISTINCT</code>, it counts only unique values.<br><br><strong>Step-by-Step Instructions:</strong><br>1. Make sure the <code>deep_space_catalog</code> database is still mounted.<br>2. Write a query that counts distinct objects matching our criteria:<br><code>SELECT COUNT(DISTINCT object_name)<br>FROM DeepSpaceObjects<br>WHERE object_type = 'Planet'<br>AND (is_habitable_candidate = TRUE<br>OR spectral_signature = 'Water');</code><br><br>This query does the following:<ul><li>Counts distinct planet names</li><li>First filters for only 'Planet' type objects</li><li>Then applies a complex filter using <code>AND</code> and <code>OR</code>:</li><ul><li>The planet must EITHER be a habitable candidate OR have water in its spectral signature</li></ul></ul><br><strong>Question:</strong> Using these criteria (<code>object_type = 'Planet'</code> AND (<code>is_habitable_candidate = TRUE</code> OR <code>spectral_signature = 'Water'</code>)), how many distinct planetary objects are identified in the entire <code>DeepSpaceObjects</code> table? Enter the count.",
                "hint": "Use a query like: <code>SELECT COUNT(DISTINCT object_name) FROM DeepSpaceObjects WHERE object_type = 'Planet' AND (is_habitable_candidate = TRUE OR spectral_signature = 'Water');</code>. Type the resulting number.",
                "solution": "SELECT COUNT(DISTINCT object_name) FROM DeepSpaceObjects WHERE object_type = 'Planet' AND (is_habitable_candidate = TRUE OR spectral_signature = 'Water');",
                "difficulty": 2,
                "points": 75,
                "timeLimit": 300,
                "timerEnabled": false,
                "successMessage": "You found 8 candidate planets. Interesting... Further analysis of their detailed telemetry reveals high M-class radiation on several, and others are primarily methane-ice. Not ideal first stops. We need a more direct approach: Let's find the *closest confirmed* habitable candidate. Time to prioritize by distance!",
                "dbAlias": "deep_space_catalog",
                "validationCriteria": {
                    "requiredDatabase": "deep_space_catalog",
                    "answerToQuestion": "8"
                },
                "mapDetails": {
                    "showOnMap": false
                },
                "nextMissionId": 4
            },
            {
                "id": 4,
                "title": "Astro-Logistics: Nearest Habitable Hope (ORDER BY)",
                "description": "Agent, that last search was too broad. Let's refine. We must prioritize potential investigation targets. From the <code>DeepSpaceObjects</code> table, retrieve all <code>'Planet'</code> type objects that are confirmed as <code>is_habitable_candidate = TRUE</code>.<br><br><strong>Part 1: Understanding Sorting with ORDER BY</strong><br>In this mission, we'll learn how to sort results using the <code>ORDER BY</code> clause:<br><ul><li><code>ORDER BY column_name</code> - Sorts results by the specified column</li><li><code>ASC</code> - Ascending order (smallest to largest, A to Z) - this is the default</li><li><code>DESC</code> - Descending order (largest to smallest, Z to A)</li></ul><br><strong>Step-by-Step Instructions:</strong><br>1. Make sure the <code>deep_space_catalog</code> database is still mounted.<br>2. Write a query that gets all habitable planets, sorted by distance:<br><code>SELECT object_name, star_system, distance_ly<br>FROM DeepSpaceObjects<br>WHERE object_type = 'Planet'<br>AND is_habitable_candidate = TRUE<br>ORDER BY distance_ly ASC;</code><br><br>This query does the following:<ul><li>Selects the planet name, its star system, and distance in light years</li><li>Filters to show only objects that are planets</li><li>Further filters to only those marked as habitable candidates</li><li>Sorts the results by distance, with closest planets first</li></ul><br><strong>Question:</strong> When you <strong>ORDER</strong> these results by <code>distance_ly</code> in <strong>ascending</strong> order, what is the <code>object_name</code> of the <em>closest</em> such planet?",
                "hint": "Use: <code>SELECT object_name FROM DeepSpaceObjects WHERE object_type = 'Planet' AND is_habitable_candidate = TRUE ORDER BY distance_ly ASC LIMIT 1;</code> The name of this single planet is your answer.",
                "solution": "SELECT object_name, star_system, distance_ly FROM DeepSpaceObjects WHERE object_type = 'Planet' AND is_habitable_candidate = TRUE ORDER BY distance_ly ASC;",
                "difficulty": 2,
                "points": 100,
                "timeLimit": 300,
                "timerEnabled": false,
                "successMessage": "Excellent prioritization! 'Earth' is indeed the closest confirmed habitable candidate on our list at only 0.0000158 light years away. This is a significant discovery! Our journey is taking us closer to our target system, Sol.",
                "dbAlias": "deep_space_catalog",
                "validationCriteria": {
                    "requiredDatabase": "deep_space_catalog",
                    "answerToQuestion": "Earth"
                },
                "mapDetails": {
                    "showOnMap": false
                },
                "nextMissionId": 5
            },
            {
                "id": 5,
                "title": "Systemic Analysis: Habitable Hotspots (GROUP BY)",
                "description": "Agent, to allocate future deep-survey resources effectively, we need a galactic neighborhood watch summary. Focus only on objects where <code>object_type = 'Planet'</code> AND <code>is_habitable_candidate = TRUE</code> from the <code>DeepSpaceObjects</code> table.<br><br><strong>Part 1: Understanding Grouping and Aggregation</strong><br>In this mission, we'll learn about grouping and aggregation:<br><ul><li><code>GROUP BY</code> - Groups rows with the same values in specified columns</li><li><code>COUNT(*)</code> - Counts the number of rows in each group</li><li><code>AS</code> - Creates column aliases for more readable results</li></ul><br><strong>Step-by-Step Instructions:</strong><br>1. Make sure the <code>deep_space_catalog</code> database is still mounted.<br>2. Write a query that groups habitable planets by their star systems:<br><code>SELECT star_system, COUNT(*) AS habitable_planet_count<br>FROM DeepSpaceObjects<br>WHERE object_type = 'Planet'<br>AND is_habitable_candidate = TRUE<br>GROUP BY star_system<br>ORDER BY habitable_planet_count DESC;</code><br><br>This query does the following:<ul><li>Groups the filtered planets by their star system</li><li>Counts how many habitable planets are in each system</li><li>Names this count 'habitable_planet_count'</li><li>Sorts by this count, showing systems with the most habitable planets first</li></ul><br><strong>Question:</strong> By <strong>GROUPING</strong> these planets by their <code>star_system</code> and counting them, which <code>star_system</code> appears to host the highest number of these promising habitable candidate planets? Provide the name of this star system.",
                "hint": "Use: <code>SELECT star_system, COUNT(*) AS habitable_planet_count FROM DeepSpaceObjects WHERE object_type = 'Planet' AND is_habitable_candidate = TRUE GROUP BY star_system ORDER BY habitable_planet_count DESC LIMIT 1;</code> The star system name is your answer.",
                "solution": "SELECT star_system, COUNT(*) AS habitable_planet_count FROM DeepSpaceObjects WHERE object_type = 'Planet' AND is_habitable_candidate = TRUE GROUP BY star_system ORDER BY habitable_planet_count DESC;",
                "difficulty": 3,
                "points": 125,
                "timeLimit": 360,
                "timerEnabled": false,
                "successMessage": "Precisely! The 'TRAPPIST-1' system shows the most habitable candidates with 4 planets, making it an excellent study target. However, our previous mission identified that Earth in the Sol system is the closest habitable planet, which makes it our priority target for immediate exploration.",
                "dbAlias": "deep_space_catalog",
                "validationCriteria": {
                    "requiredDatabase": "deep_space_catalog",
                    "answerToQuestion": "TRAPPIST-1"
                },
                "mapDetails": {
                    "showOnMap": false
                },
                "nextMissionId": 6
            },
            {
                "id": 6,
                "title": "The Sol Prospect: Finding Home (All Commands)",
                "description": "This is it, Agent! Intelligence confirms our target is 'Earth' within the 'Sol' system. Access the detailed local database: <code>solar_system_archive</code> (mount it now!).<br><br><strong>Part 1: Combining SQL Skills</strong><br>In this final mission, we'll combine everything we've learned:<br><ul><li>Mounting a new database</li><li>Multiple filter conditions with <code>AND</code></li><li>Sorting with <code>ORDER BY</code></li><li>Limiting results with <code>LIMIT</code></li></ul><br><strong>Step-by-Step Instructions:</strong><br>1. First, mount the <code>solar_system_archive</code> database using the DB REGISTRY.<br>2. Write a query that finds Earth by its characteristics:<br><code>SELECT planet_name, orbital_position, atmosphere_composition<br>FROM SolSystemPlanets<br>WHERE type = 'Rocky'<br>AND orbital_position = 3<br>AND biosignature_detected = TRUE<br>ORDER BY magnetic_field_strength_tesla DESC<br>LIMIT 1;</code><br><br>This query does the following:<ul><li>Searches for rocky planets in the third orbital position</li><li>Filters to only those with detected biosignatures</li><li>In case of multiple matches, sorts by magnetic field strength</li><li>Returns only the top result</li></ul><br>Earth has these known characteristics within this archive:<br>1. <code>type = 'Rocky'</code><br>2. <code>orbital_position = 3</code><br>3. <code>biosignature_detected = TRUE</code><br><br><strong>Question:</strong> Using these exact criteria in your query on the <code>SolSystemPlanets</code> table, and retrieving its <code>planet_name</code>, what is the confirmed name of our destination planet? In case of any anomalies resulting in multiple matches, prioritize the one with the highest <code>magnetic_field_strength_tesla</code> (DESC) and take only the top one (<code>LIMIT 1</code>).",
                "hint": "Mount `solar_system_archive`. Query: <code>SELECT planet_name FROM SolSystemPlanets WHERE type = 'Rocky' AND orbital_position = 3 AND biosignature_detected = TRUE ORDER BY magnetic_field_strength_tesla DESC LIMIT 1;</code> The answer is the name.",
                "solution": "SELECT planet_name, orbital_position, atmosphere_composition FROM SolSystemPlanets WHERE type = 'Rocky' AND orbital_position = 3 AND biosignature_detected = TRUE ORDER BY magnetic_field_strength_tesla DESC LIMIT 1;",
                "difficulty": 3,
                "points": 150,
                "timeLimit": 420,
                "timerEnabled": false,
                "successMessage": "TARGET ACQUIRED! 'Earth' confirmed! Your SQL mastery has guided us across the void. Data relayed. Stand by to engage the planetary observation interface on the interactive map. Mission success!",
                "dbAlias": "solar_system_archive",
                "validationCriteria": {
                    "requiredDatabase": "solar_system_archive",
                    "answerToQuestion": "Earth"
                },
                "mapDetails": {
                    "showOnMap": false
                },
                "nextMissionId": 7
            },
            {
                "id": 7,
                "title": "Tutorial: Interactive Map",
                "description": "Great job finding Earth! Now let's explore the interactive map feature to locate key mission destinations.<br><br><strong>Part 1: Understanding Interactive Database Visualization</strong><br>SQL isn't just about text results - we can visualize geographical data too. In this mission, we'll learn how to:<br><ul><li>Mount a specialized geographic database</li><li>Use SQL to query geographical data</li><li>View results on the interactive map</li></ul><br><strong>Step-by-Step Instructions:</strong><br>1. Click the <strong>DB REGISTRY</strong> button at the top of the screen<br>2. Find the <strong>maps</strong> database and click <strong>MOUNT</strong><br>3. Close the DB Registry panel using the X button<br>4. In the SQL console, enter the following query:<br><code>SELECT * FROM countries WHERE continent = 'North America';</code><br><br>This query does the following:<ul><li>It retrieves all countries in North America</li><li>The results will appear in the results area below</li><li>The map integration will automatically highlight these countries</li><li>You can click on the MAP button at the top to open the full interactive map</li></ul>",
                "hint": "First mount the 'maps' database, then run: <code>SELECT * FROM countries WHERE continent = 'North America';</code> to view North American countries. You can then open the map to see them highlighted.",
                "solution": "SELECT * FROM countries WHERE continent = 'North America';",
                "difficulty": 1,
                "points": 50,
                "timeLimit": 300,
                "timerEnabled": false,
                "successMessage": "Perfect! You've successfully queried geographical data and seen it visualized on the map. This skill will be essential for locating mission sites around the world. IMPORTANT: Your next missions will be accessed through the MAP interface. Open the map, locate the mission markers, and click on them to begin those missions.",
                "dbAlias": "maps",
                "validationCriteria": {
                    "databaseMounted": true,
                    "requiredDatabase": "maps",
                    "keywords": [
                        "SELECT",
                        "FROM",
                        "countries",
                        "continent",
                        "North America"
                    ]
                },
                "mapDetails": {
                    "showOnMap": false
                },
                "nextMissionId": 8
            },
            {
                "id": 8,
                "title": "Global Geography Analysis",
                "description": "Welcome to the Geographic Data Analysis mission! In this mission, you will explore country data while visualizing the results on the interactive world map.<br><br><strong>Part 1: Targeting Mission Locations</strong><br>Our first earthside mission will take place in New York City, USA. Let's locate it using SQL and the interactive map:<br><ul><li>Use SQL to query specific location data</li><li>Filter results to find our mission destination</li><li>Open the interactive map to see the highlighted results</li></ul><br><strong>Step-by-Step Instructions:</strong><br>1. Make sure the <code>maps</code> database is still mounted<br>2. Write a query to find information about the United States:<br><code>SELECT * FROM countries WHERE country = 'United States';</code><br><br>3. Next, let's narrow down to cities in the United States:<br><code>SELECT * FROM cities WHERE country = 'United States';</code><br><br>4. After viewing the results, click the <strong>MAP</strong> button at the top of the screen to open the interactive map and see the highlighted locations.<br><br>These queries will display information about the United States and its major cities, including New York where your first field mission will take place.",
                "hint": "Run <code>SELECT * FROM cities WHERE country = 'United States';</code> to see US cities including New York. Then click the MAP button to view the full interactive map.",
                "solution": "SELECT * FROM cities WHERE country = 'United States';",
                "difficulty": 2,
                "points": 75,
                "timeLimit": 300,
                "timerEnabled": false,
                "successMessage": "Excellent! You've successfully located New York City, our first mission location. You've mastered using SQL queries to find geographic data and using the interactive map for visualization. Your next mission awaits in New York City!",
                "dbAlias": "maps",
                "validationCriteria": {
                    "databaseMounted": true,
                    "requiredDatabase": "maps",
                    "keywords": [
                        "SELECT",
                        "FROM",
                        "cities",
                        "country",
                        "United States"
                    ]
                },
                "mapDetails": {
                    "showOnMap": true,
                    "country": "United States",
                    "location": [
                        -74.0060,
                        40.7128
                    ],
                    "description": "Locate New York City, your first mission destination."
                },
                "nextMissionId": 9
            },
            {
                "id": 9,
                "title": "Mission: First Contact (New York)",
                "description": "The Galactic Council needs information about Earth's major population centers. Our first target is New York.<br><br><strong>Part 1: Applying SQL Skills on Earth Data</strong><br>In this mission, we'll apply the SQL skills we've learned to query Earth-specific databases:<br><ul><li>Mount a specialized Earth database</li><li>Use the WHERE clause to find specific city data</li><li>Extract population information for analysis</li></ul><br><strong>Step-by-Step Instructions:</strong><br>1. Click the <strong>DB REGISTRY</strong> button and mount the <code>geo_data_earth</code> database<br>2. Write a query to find information about New York City:<br><code>SELECT population, country<br>FROM EarthCities<br>WHERE city_name = 'New York';</code><br><br>This query does the following:<ul><li>Selects only the population and country information</li><li>Filters to show only data for the city named 'New York'</li><li>Returns demographic information needed by the Galactic Council</li></ul><br><strong>Expected Outcome:</strong><br>The query should return a single row with New York's population count and its country (United States).",
                "hint": "Mount `geo_data_earth`. Use `SELECT population, country FROM EarthCities WHERE city_name = 'New York';`",
                "solution": "SELECT population, country FROM EarthCities WHERE city_name = 'New York';",
                "difficulty": 1,
                "points": 100,
                "timeLimit": 300,
                "timerEnabled": false,
                "successMessage": "Excellent work, SQL Knight! You've successfully retrieved the data for New York. This is vital for the Galactic Council.",
                "dbAlias": "geo_data_earth",
                "validationCriteria": {
                    "expectedRows": 1,
                    "mustContainColumns": ["population", "country"],
                    "queryStructureChecks": [ 
                        {"checkType": "filter", "column": "city_name", "expectedValue": "New York"}
                    ],
                    "keywords": ["SELECT", "FROM", "EarthCities", "WHERE"]
                },
                "mapDetails": {
                    "showOnMap": true,
                    "country": "United States",
                    "location": [
                        -74.0060,
                        40.7128
                    ],
                    "description": "First Contact mission in New York. Objective: Query city data."
                },
                "nextMissionId": 10
            },
            {
                "id": 10,
                "title": "Mission: Resource Discovery (London)",
                "description": "The Galactic Trading Federation needs to know which key terrestrial resources are found near major European trade hubs. Focus on London.<br><br><strong>Part 1: Filtering and Sorting Earth Resources</strong><br>In this mission, we'll combine multiple SQL techniques to analyze resource data:<br><ul><li>Use multiple filter conditions with AND</li><li>Compare values using the > operator</li><li>Sort results by value in descending order</li></ul><br><strong>Step-by-Step Instructions:</strong><br>1. Make sure the <code>geo_data_earth</code> database is still mounted<br>2. Write a query to find valuable resources in the United Kingdom:<br><code>SELECT resource_name, market_value<br>FROM EarthResources<br>WHERE country_origin = 'United Kingdom'<br>AND market_value > 5000<br>ORDER BY market_value DESC;</code><br><br>This query does the following:<ul><li>Selects resource names and their market values</li><li>Applies two filter conditions:</li><ul><li>Resources must be from the United Kingdom</li><li>Market value must exceed 5000</li></ul><li>Sorts the results with highest value resources first</li></ul><br><strong>Question:</strong><br>After running the query, what is the name of the most valuable resource (highest market_value) in the United Kingdom? Enter the exact resource name.",
                "hint": "Use `SELECT resource_name, market_value FROM EarthResources WHERE country_origin = 'United Kingdom' AND market_value > 5000 ORDER BY market_value DESC;` and note the name of the resource with the highest market_value.",
                "solution": "SELECT resource_name, market_value FROM EarthResources WHERE country_origin = 'United Kingdom' AND market_value > 5000 ORDER BY market_value DESC;",
                "difficulty": 2,
                "points": 150,
                "timeLimit": 300,
                "timerEnabled": false,
                "successMessage": "Outstanding work! The Galactic Trading Federation can now prioritize the most valuable resources for their European commercial routes.",
                "dbAlias": "geo_data_earth",
                "validationCriteria": {
                    "requiredDatabase": "geo_data_earth",
                    "answerToQuestion": "Scottish Rare Earth Elements"
                },
                "mapDetails": {
                    "showOnMap": true,
                    "country": "United Kingdom",
                    "location": [
                        -0.1278,
                        51.5074
                    ],
                    "description": "Resource Discovery mission in London. Objective: Query valuable UK resources."
                },
                "nextMissionId": 11
            },
            {
                "id": 11,
                "title": "Mission: Cultural Heritage Scan (Tokyo)",
                "description": "The Interstellar Preservation Society is cataloging sites of significant cultural importance. For Tokyo, they need a list of cultural sites ordered by their age.<br><br><strong>Part 1: Complex Filtering with AND/OR Combinations</strong><br>In this mission, we'll use more advanced filtering and sorting:<br><ul><li>Combine AND and OR conditions with proper grouping</li><li>Sort results chronologically using ASC order</li><li>Extract cultural heritage information</li></ul><br><strong>Step-by-Step Instructions:</strong><br>1. Make sure the <code>geo_data_earth</code> database is still mounted<br>2. Write a query to find significant cultural sites in Tokyo:<br><code>SELECT site_name, year_established<br>FROM EarthSites<br>WHERE city = 'Tokyo'<br>AND (type = 'Cultural' OR importance_level >= 8)<br>ORDER BY year_established ASC;</code><br><br>This query does the following:<ul><li>Selects site names and their establishment years</li><li>First filters for Tokyo sites only</li><li>Then applies a complex condition where either:</li><ul><li>The site type is 'Cultural', OR</li><li>The site has an importance level of 8 or higher</li></ul><li>Orders results from oldest to newest sites</li></ul><br><strong>Question:</strong><br>What is the name of the oldest cultural or important (importance_level >= 8) site in Tokyo? Enter the exact site name from your results.",
                "hint": "Use `SELECT site_name, year_established FROM EarthSites WHERE city = 'Tokyo' AND (type = 'Cultural' OR importance_level >= 8) ORDER BY year_established ASC;` and look at the first result (oldest site).",
                "solution": "SELECT site_name, year_established FROM EarthSites WHERE city = 'Tokyo' AND (type = 'Cultural' OR importance_level >= 8) ORDER BY year_established ASC;",
                "difficulty": 2,
                "points": 200,
                "timeLimit": 300,
                "timerEnabled": false,
                "successMessage": "Well done! The Interstellar Preservation Society can now catalog Tokyo's key heritage sites effectively, starting with the oldest site: Sensō-ji Temple from 645 CE.",
                "dbAlias": "geo_data_earth",
                "validationCriteria": {
                    "requiredDatabase": "geo_data_earth",
                    "answerToQuestion": "Sensō-ji Temple"
                },
                "mapDetails": {
                    "showOnMap": true,
                    "country": "Japan",
                    "location": [
                        139.6917,
                        35.6895
                    ],
                    "description": "Cultural Heritage Scan in Tokyo. Objective: Query significant sites."
                },
                "nextMissionId": 12
            },
            {
                "id": 12,
                "title": "Paris With Love: Sustainable Tech Analysis",
                "description": "A research team in Paris is studying historical sustainability techniques. Access the `GlobalTechArchive` database (alias `global_tech`).<br><br><strong>Part 1: Combining Multiple Techniques</strong><br>In this mission, we'll combine several SQL techniques into a more complex query:<br><ul><li>Multiple filter conditions with logical operators</li><li>Sorting with ORDER BY</li><li>Using LIMIT to restrict results</li></ul><br><strong>Step-by-Step Instructions:</strong><br>1. Mount the <code>global_tech</code> database using the DB REGISTRY<br>2. Write a query to find sustainable practices in France:<br><code>SELECT practice_name, efficiency_rating<br>FROM SustainabilityPractices<br>WHERE country_of_origin = 'France'<br>AND (category = 'Urban' OR category = 'Agricultural')<br>ORDER BY efficiency_rating DESC<br>LIMIT 3;</code><br><br>This query does the following:<ul><li>Selects the practice name and its efficiency rating</li><li>Filters for only French practices</li><li>Further filters to only Urban OR Agricultural categories</li><li>Sorts by efficiency rating from highest to lowest</li><li>Returns only the top 3 most efficient practices</li></ul><br><strong>Expected Outcome:</strong><br>The query will return the three most efficient sustainable practices from France's urban and agricultural sectors, which can help the Paris research team implement historical sustainability techniques in modern settings.",
                "hint": "Mount `global_tech`. Use `SELECT practice_name, efficiency_rating FROM SustainabilityPractices WHERE country_of_origin = 'France' AND (category = 'Urban' OR category = 'Agricultural') ORDER BY efficiency_rating DESC LIMIT 3;`",
                "solution": "SELECT practice_name, efficiency_rating FROM SustainabilityPractices WHERE country_of_origin = 'France' AND (category = 'Urban' OR category = 'Agricultural') ORDER BY efficiency_rating DESC LIMIT 3;",
                "difficulty": 3,
                "points": 200,
                "timeLimit": 300,
                "timerEnabled": false,
                "successMessage": "Magnifique! You've unlocked ancient sustainability knowledge that will help modern Paris. Your combined use of WHERE, OR, ORDER BY, and LIMIT was flawless!",
                "dbAlias": "global_tech",
                "validationCriteria": {
                    "keywords": ["SELECT", "FROM", "SustainabilityPractices", "WHERE", "AND", "OR", "ORDER BY", "DESC", "LIMIT"],
                    "queryStructureChecks": [
                        {"checkType": "filter", "column": "country_of_origin", "expectedValue": "France"},
                        {"checkType": "limit", "expectedValue": 3}
                    ],
                    "queryLogicChecks": [
                         {"clause": "WHERE", "mustContainLogicCombination": {"AND": ["country_of_origin = 'France'", {"OR": ["category = 'Urban'", "category = 'Agricultural'"]}]}}
                    ],
                    "ordered": true,
                    "orderColumn": "efficiency_rating",
                    "orderDirection": "desc",
                    "mustContainColumns": ["practice_name", "efficiency_rating"],
                    "expectedRows": 3
                },
                "mapDetails": {
                    "showOnMap": true,
                    "country": "France",
                    "location": [
                        2.3522,
                        48.8566
                    ],
                    "description": "Active mission in Paris: Query sustainable tech."
                },
                "nextMissionId": 13
            },
            {
                "id": 13,
                "title": "Mission: Sydney Bio-Diversity Report (GROUP BY)",
                "description": "Environmental scientists in Sydney, Australia require a summary of wildlife sightings. Use the `RegionalWildlifeDB` (alias `aus_wildlife`).<br><br><strong>Part 1: Advanced Aggregation and Filtering</strong><br>In this mission, we'll learn more advanced aggregation techniques:<br><ul><li>Using COUNT with the DISTINCT keyword</li><li>Filtering with complex OR conditions</li><li>Combining GROUP BY with ORDER BY</li><li>Creating more descriptive column aliases</li></ul><br><strong>Step-by-Step Instructions:</strong><br>1. Mount the <code>aus_wildlife</code> database using the DB REGISTRY<br>2. Write a query to analyze endangered species across Australian regions:<br><code>SELECT state_province, COUNT(DISTINCT species_name) AS endangered_species_count<br>FROM SightingsAustralia<br>WHERE conservation_status = 'Endangered'<br>OR conservation_status = 'Critically Endangered'<br>GROUP BY state_province<br>ORDER BY endangered_species_count DESC;</code><br><br>This query does the following:<ul><li>Groups wildlife sightings by state/province</li><li>Counts only distinct species names (to avoid counting the same species multiple times)</li><li>Filters to include only endangered or critically endangered species</li><li>Names the count column 'endangered_species_count' for clarity</li><li>Sorts the results to show regions with the most endangered species first</li></ul><br><strong>Expected Outcome:</strong><br>The query will generate a biodiversity report showing which Australian states/provinces have the highest numbers of distinct endangered species, helping scientists prioritize conservation efforts.",
                "hint": "Mount `aus_wildlife`. Use `SELECT state_province, COUNT(DISTINCT species_name) AS endangered_species_count FROM SightingsAustralia WHERE conservation_status = 'Endangered' OR conservation_status = 'Critically Endangered' GROUP BY state_province ORDER BY endangered_species_count DESC;`",
                "solution": "SELECT state_province, COUNT(DISTINCT species_name) AS endangered_species_count FROM SightingsAustralia WHERE conservation_status = 'Endangered' OR conservation_status = 'Critically Endangered' GROUP BY state_province ORDER BY endangered_species_count DESC;",
                "difficulty": 3,
                "points": 250,
                "timeLimit": 420,
                "timerEnabled": false,
                "successMessage": "Excellent analysis! The scientists now have a clear report on endangered species distribution in Australia thanks to your GROUP BY and aggregate skills.",
                "dbAlias": "aus_wildlife",
                "validationCriteria": {
                    "keywords": ["SELECT", "COUNT", "DISTINCT", "FROM", "SightingsAustralia", "WHERE", "OR", "GROUP BY", "ORDER BY", "DESC"],
                    "queryLogicChecks": [
                        {"clause": "WHERE", "mustContainLogicCombination": {"OR": ["conservation_status = 'Endangered'", "conservation_status = 'Critically Endangered'"]}}
                    ],
                    "aggregation": true,
                    "groupBy": ["state_province"],
                    "aggregateFunction": "COUNT",
                    "aggregateColumn": "species_name", 
                    "distinctInAggregation": true,
                    "ordered": true,
                    "orderColumn": "endangered_species_count",
                    "orderDirection": "desc",
                    "mustContainColumns": ["state_province", "endangered_species_count"]
                },
                "mapDetails": {
                    "showOnMap": true,
                    "country": "Australia",
                    "location": [
                        151.2093,
                        -33.8688
                    ],
                    "description": "Sydney Bio-Diversity Report. Objective: Group and count endangered species."
                },
                "nextMissionId": 14
            },
            {
                "id": 14,
                "title": "Mission: Rio Resource Value Analysis (Complex Query)",
                "description": "The Global Economic Council in Rio de Janeiro, Brazil needs a detailed report. Use `SouthAmericaEconomyDB` (alias `sa_econ`).<br><br><strong>Part 1: Advanced Filtering with HAVING</strong><br>In this mission, we'll learn the most advanced SQL concepts so far:<br><ul><li>Using the SUM function to calculate totals</li><li>Filtering grouped results with the HAVING clause</li><li>Using AVG to calculate averages</li><li>Combining multiple aggregate functions in one query</li></ul><br><strong>Step-by-Step Instructions:</strong><br>1. Mount the <code>sa_econ</code> database using the DB REGISTRY<br>2. Write a complex query to analyze natural resource exports:<br><code>SELECT country, SUM(export_value) AS total_natural_resource_export_value<br>FROM EconomicActivities<br>WHERE item_type = 'NaturalResource'<br>GROUP BY country<br>HAVING AVG(resource_stability_index) > 0.6<br>ORDER BY total_natural_resource_export_value DESC<br>LIMIT 5;</code><br><br>This query does the following:<ul><li>Filters for only natural resource type items</li><li>Groups these items by country</li><li>Calculates the sum of export values for each country</li><li>Uses HAVING to filter out countries with average stability index ≤ 0.6</li><li>Orders countries by their total export value (highest first)</li><li>Returns only the top 5 countries</li></ul><br><strong>Understanding HAVING vs WHERE:</strong><br><ul><li>WHERE filters individual rows before grouping</li><li>HAVING filters groups after they are formed</li><li>HAVING can use aggregate functions like AVG, SUM, COUNT</li></ul><br><strong>Expected Outcome:</strong><br>The query will identify the top 5 stable countries with the highest natural resource export values, giving the Global Economic Council crucial information for investment strategies.",
                "hint": "Mount `sa_econ`. A complex one! `SELECT country, SUM(export_value) AS total_natural_resource_export_value FROM EconomicActivities WHERE item_type = 'NaturalResource' GROUP BY country HAVING AVG(resource_stability_index) > 0.6 ORDER BY total_natural_resource_export_value DESC LIMIT 5;`",
                "solution": "SELECT country, SUM(export_value) AS total_natural_resource_export_value FROM EconomicActivities WHERE item_type = 'NaturalResource' GROUP BY country HAVING AVG(resource_stability_index) > 0.6 ORDER BY total_natural_resource_export_value DESC LIMIT 5;",
                "difficulty": 4,
                "points": 300,
                "timeLimit": 480,
                "timerEnabled": false,
                "successMessage": "Outstanding work! The Council now has critical insight into South American natural resource export values. Your full command of SQL, including aggregation, filtering, ordering, and limiting results, is exemplary!",
                "dbAlias": "sa_econ",
                "validationCriteria": {
                    "keywords": ["SELECT", "SUM", "FROM", "EconomicActivities", "WHERE", "GROUP BY", "HAVING", "AVG", "ORDER BY", "DESC", "LIMIT"],
                    "queryStructureChecks": [
                        {"checkType": "filter", "column": "item_type", "expectedValue": "NaturalResource"},
                        {"checkType": "limit", "expectedValue": 5}
                    ],
                    "aggregation": true,
                    "groupBy": ["country"],
                    "aggregateFunction": "SUM",
                    "aggregateColumn": "export_value",
                    "havingClauseCheck": {"aggregateFunction": "AVG", "column": "resource_stability_index", "operator": ">", "value": 0.6},
                    "ordered": true,
                    "orderColumn": "total_natural_resource_export_value",
                    "orderDirection": "desc",
                    "mustContainColumns": ["country", "total_natural_resource_export_value"],
                    "expectedRows": 5
                },
                "mapDetails": {
                    "showOnMap": true,
                    "country": "Brazil",
                    "location": [
                        -43.1729,
                        -22.9068
                    ],
                    "description": "Rio Resource Analysis mission. Objective: Complex aggregation and filtering."
                },
                "nextMissionId": 100
            },

            {
                "id": 100,
                "title": "Data Visualization for Global Goals (SDG Focus)",
                "description": "Agent, after analyzing regional economic data, our focus shifts to broader global development. Data visualization can illuminate challenges and progress towards Sustainable Development Goals (SDGs).<br><br><strong>Part 1: Introduction to Visual Analysis</strong><br>We'll explore how charts transform raw numbers into understandable insights.<br><ul><li>Execute SQL to retrieve development indicators.</li><li>Use the <strong>GRAPH</strong> button to visualize results.</li><li>Experiment with Bar, Line, and Pie charts.</li></ul><br><strong>Step-by-Step Instructions:</strong><br>1. Mount the <code>sdg_data_hub</code> database (alias <code>sdg_hub</code>).<br>2. Query key indicators for different regions:<br><code>SELECT region, indicator_name, value<br>FROM GlobalDevelopmentIndicators<br>WHERE year = 2023 AND indicator_name IN ('LiteracyRate', 'AccessToCleanWater', 'RenewableEnergyUsage');</code><br><br>3. Click <strong>GRAPH</strong>. Observe how different chart types (Bar, Pie) represent this data. For a time-series view (if data across years was queried), a Line chart would be effective.<br><br>This mission introduces visualizing SDG-related data for impactful reporting.",
                "hint": "Mount `sdg_hub`. Run the query <code>SELECT region, indicator_name, value FROM GlobalDevelopmentIndicators WHERE year = 2023 AND indicator_name IN ('LiteracyRate', 'AccessToCleanWater', 'RenewableEnergyUsage');</code> then click GRAPH. Explore Bar and Pie charts.",
                "solution": "SELECT region, indicator_name, value FROM GlobalDevelopmentIndicators WHERE year = 2023 AND indicator_name IN ('LiteracyRate', 'AccessToCleanWater', 'RenewableEnergyUsage');",
                "difficulty": 1,
                "points": 75,
                "timeLimit": 300,
                "timerEnabled": false,
                "successMessage": "Excellent! You've seen how data visualization with charts makes complex SDG data more accessible. This is crucial for tracking global progress.",
                "dbAlias": "sdg_hub",
                "validationCriteria": {
                    "keywords": ["SELECT", "FROM", "GlobalDevelopmentIndicators", "WHERE", "IN"],
                    "mustContainColumns": ["region", "indicator_name", "value"],
                    "minRows": 3
                },
                "mapDetails": {
                    "showOnMap": true,
                    "country": "Global",
                    "location": [0, 0],
                    "zoomLevel": 1,
                    "description": "Visualizing global SDG indicators."
                },
                "nextMissionId": 101
        },
        {
            "id": 101,
            "title": "Connecting Education & Opportunity (Intro to JOINs for SDGs 4 & 8)",
            "description": "Visualizing single datasets is useful. Now, let's combine data to find relationships, like linking education levels (SDG 4: Quality Education) to employment outcomes (SDG 8: Decent Work and Economic Growth).<br><br><strong>Part 1: Understanding JOIN Operations</strong><br>JOINs merge rows from two or more tables based on a related column.<br><ul><li>Use JOIN to connect tables.</li><li>Specify join conditions with ON.</li></ul><br><strong>Step-by-Step Instructions:</strong><br>1. Mount the <code>education_employment_link</code> database (alias <code>edu_work_data</code>).<br>2. Join education statistics with employment statistics by country:<br><code>SELECT es.country, es.avg_years_schooling, emps.employment_rate<br>FROM EducationStats AS es<br>JOIN EmploymentStats AS emps ON es.country_code = emps.country_code;</code><br><br>Click <strong>GRAPH</strong> and select the SCATTER plot. This can help visualize correlation between schooling and employment.",
            "hint": "Mount `edu_work_data`. Run <code>SELECT es.country, es.avg_years_schooling, emps.employment_rate FROM EducationStats AS es JOIN EmploymentStats AS emps ON es.country_code = emps.country_code;</code> Then view with a Scatter plot.",
            "solution": "SELECT es.country, es.avg_years_schooling, emps.employment_rate FROM EducationStats AS es JOIN EmploymentStats AS emps ON es.country_code = emps.country_code;",
            "difficulty": 2,
            "points": 100,
            "timeLimit": 300,
            "timerEnabled": false,
            "successMessage": "Great! You've used JOIN to connect education and employment data. Scatter plots are useful for spotting potential correlations between such variables.",
            "dbAlias": "edu_work_data",
            "validationCriteria": {
                "keywords": ["SELECT", "FROM", "EducationStats", "JOIN", "EmploymentStats", "ON"],
                "mustContainColumns": ["country", "avg_years_schooling", "employment_rate"],
                "minRows": 5
            },
            "mapDetails": {
                "showOnMap": false
            },
            "nextMissionId": 102
        },
        {
            "id": 102,
            "title": "Urban Green Spaces & Population (INNER JOIN for SDG 11)",
            "description": "INNER JOINs are crucial for SDG 11 (Sustainable Cities and Communities) by finding exact matches, like cities with both population data and recorded green space initiatives.<br><br><strong>Part 1: Focusing with INNER JOIN</strong><br>INNER JOIN returns only rows where there's a match in both tables.<br><br><strong>Step-by-Step Instructions:</strong><br>1. Ensure <code>urban_sustainability_data</code> (alias <code>city_sustain_db</code>) is mounted.<br>2. Find cities that have entries in both population and green initiative tables:<br><code>SELECT cp.city_name, cp.population, gi.project_name AS green_initiative_project<br>FROM CityPopulations AS cp<br>INNER JOIN GreenInitiatives AS gi ON cp.city_id = gi.city_id<br>WHERE cp.population > 1000000<br>ORDER BY cp.population DESC;</code><br><br>Click <strong>GRAPH</strong> and try a BAR chart to see number of listed green initiatives per populous city if you were to GROUP BY city and COUNT projects. For this query, observe the direct linkage.<br><br><strong>Question:</strong> For cities with over 1,000,000 population, how many `green_initiative_project` are listed for 'Metro City'?",
            "hint": "Mount `city_sustain_db`. Query: <code>SELECT cp.city_name, cp.population, gi.project_name AS green_initiative_project FROM CityPopulations AS cp INNER JOIN GreenInitiatives AS gi ON cp.city_id = gi.city_id WHERE cp.population > 1000000 ORDER BY cp.population DESC;</code> Look for 'Metro City'. (Example data needed for a fixed answer, for now, it validates query structure)",
            "solution": "SELECT cp.city_name, cp.population, gi.project_name AS green_initiative_project FROM CityPopulations AS cp INNER JOIN GreenInitiatives AS gi ON cp.city_id = gi.city_id WHERE cp.population > 1000000 ORDER BY cp.population DESC;",
            "difficulty": 2,
            "points": 125,
            "timeLimit": 300,
            "timerEnabled": false,
            "successMessage": "Excellent! INNER JOIN helped you link cities to their specific green initiatives, a key aspect of sustainable urban development (SDG 11).",
            "dbAlias": "city_sustain_db",
            "validationCriteria": {
                "keywords": ["SELECT", "FROM", "CityPopulations", "INNER JOIN", "GreenInitiatives", "ON", "WHERE"],
                "mustContainColumns": ["city_name", "population", "green_initiative_project"],
                "answerToQuestion": "3"
            },
            "mapDetails": {
                "showOnMap": false
            },
            "nextMissionId": 103
        },
        {
            "id": 103,
            "title": "Educational Resource Availability (LEFT JOIN for SDG 4)",
            "description": "For SDG 4 (Quality Education), it's vital to know resource distribution. LEFT JOIN helps list all educational institutions, even those for which we lack specific resource data, highlighting gaps.<br><br><strong>Part 1: Inclusive Reporting with LEFT JOIN</strong><br>LEFT JOIN returns all rows from the left table and matched rows from the right; if no match, NULLs appear for right table columns.<br><br><strong>Step-by-Step Instructions:</strong><br>1. Mount <code>education_infra_db</code> (alias <code>edu_data</code>).<br>2. List all schools and their reported internet access status (if available):<br><code>SELECT s.school_name, s.district, dr.has_internet<br>FROM Schools AS s<br>LEFT JOIN DigitalResourceReports AS dr ON s.school_id = dr.school_id<br>ORDER BY s.district, s.school_name;</code><br><br>Click <strong>GRAPH</strong>. A Line chart based on a count of schools with `has_internet = TRUE`, `has_internet = FALSE`, and where `has_internet IS NULL` would show the reporting coverage.<br><br><strong>Question:</strong> How many schools have `NULL` for `has_internet`, indicating no report found?",
            "hint": "Mount `edu_data`. Run <code>SELECT s.school_name, dr.has_internet FROM Schools AS s LEFT JOIN DigitalResourceReports AS dr ON s.school_id = dr.school_id;</code> Count where `has_internet` is NULL.",
            "solution": "SELECT s.school_name, s.district, dr.has_internet FROM Schools AS s LEFT JOIN DigitalResourceReports AS dr ON s.school_id = dr.school_id ORDER BY s.district, s.school_name;",
            "difficulty": 2,
            "points": 125,
            "timeLimit": 300,
            "timerEnabled": false,
            "successMessage": "Perfect! LEFT JOIN showed all schools, clearly identifying those missing digital resource reports. This is crucial for SDG 4 resource allocation.",
            "dbAlias": "edu_data",
            "validationCriteria": {
                "keywords": ["SELECT", "FROM", "Schools", "LEFT JOIN", "DigitalResourceReports", "ON"],
                "mustContainColumns": ["school_name", "has_internet"],
                "answerToQuestion": "2"
            },
            "mapDetails": {
                "showOnMap": false
            },
            "nextMissionId": 104
        },
        {
            "id": 104,
            "title": "Aligning Skills & Economic Sectors (Multi-JOIN for SDGs 4 & 8)",
            "description": "To address SDG 4 (Education) and SDG 8 (Economic Growth), we need to link economic sectors, the skills they demand, and available training programs. This requires joining multiple tables.<br><br><strong>Part 1: Complex Relationships with Multi-Table JOINs</strong><br><br><strong>Step-by-Step Instructions:</strong><br>1. Mount <code>workforce_development_db</code> (alias <code>skills_db</code>).<br>2. Create a query linking sectors, skills, and training programs:<br><code>SELECT sec.sector_name, ski.skill_name, tp.program_name, tp.institution_name<br>FROM EconomicSectors AS sec<br>JOIN RequiredSkills AS ski ON sec.sector_id = ski.sector_id<br>JOIN TrainingPrograms AS tp ON ski.skill_id = tp.skill_id<br>WHERE sec.sector_name = 'Renewable Energy';</code><br><br>After running, click <strong>GRAPH</strong>. A TREEMAP could visualize how training programs for 'Renewable Energy' skills are distributed, possibly grouped by institution or specific skill.",
            "hint": "Mount `skills_db`. Use: <code>SELECT sec.sector_name, ski.skill_name, tp.program_name FROM EconomicSectors AS sec JOIN RequiredSkills AS ski ON sec.sector_id = ski.sector_id JOIN TrainingPrograms AS tp ON ski.skill_id = tp.skill_id WHERE sec.sector_name = 'Renewable Energy';</code>",
            "solution": "SELECT sec.sector_name, ski.skill_name, tp.program_name, tp.institution_name FROM EconomicSectors AS sec JOIN RequiredSkills AS ski ON sec.sector_id = ski.sector_id JOIN TrainingPrograms AS tp ON ski.skill_id = tp.skill_id WHERE sec.sector_name = 'Renewable Energy';",
            "difficulty": 3,
            "points": 150,
            "timeLimit": 360,
            "timerEnabled": false,
            "successMessage": "Outstanding! You've mapped a complex relationship from economic sectors to specific skills and the training programs addressing them – vital for workforce development.",
            "dbAlias": "skills_db",
            "validationCriteria": {
                "keywords": ["SELECT", "FROM", "EconomicSectors", "JOIN", "RequiredSkills", "ON", "JOIN", "TrainingPrograms", "ON", "WHERE"],
                "mustContainColumns": ["sector_name", "skill_name", "program_name"],
                "queryStructureChecks": [
                    {"checkType": "filter", "column": "sector_name", "expectedValue": "Renewable Energy"}
                ],
                "minRows": 1
            },
            "mapDetails": {
                "showOnMap": false
            },
            "nextMissionId": 105
        },
        {
            "id": 105,
            "title": "Marine Protection Analysis (Aliases in JOINs for SDG 14)",
            "description": "Analyzing Marine Protected Areas (MPAs), species sightings, and threats (SDG 14: Life Below Water) involves complex queries. Table aliases are key for readability.<br><br><strong>Part 1: Simplifying with Table Aliases</strong><br><br><strong>Step-by-Step Instructions:</strong><br>1. Mount <code>ocean_guard_db</code> (alias <code>marine_db</code>).<br>2. List MPAs, endangered species sighted, and recorded threats, focusing on high severity:<br><code>SELECT mpa.mpa_name, ess.species_name AS endangered_species, rt.threat_type<br>FROM MarineProtectedAreas AS mpa<br>JOIN EndangeredSpeciesSightings AS ess ON mpa.mpa_id = ess.mpa_id<br>JOIN RecordedThreats AS rt ON mpa.mpa_id = rt.mpa_id<br>WHERE rt.severity_level >= 4 AND ess.conservation_status = 'CriticallyEndangered'<br>ORDER BY mpa.mpa_name<br>LIMIT 10;</code><br><br>Click <strong>GRAPH</strong>. A HISTOGRAM showing the frequency of `threat_type` for these critical sightings would be insightful. (This requires grouping by threat_type and counting).<br><br>Your query provides the raw data for such analysis.",
            "hint": "Mount `marine_db`. Use aliases: <code>SELECT mpa.mpa_name, ess.species_name, rt.threat_type FROM MarineProtectedAreas AS mpa JOIN EndangeredSpeciesSightings AS ess ON mpa.mpa_id = ess.mpa_id JOIN RecordedThreats AS rt ON mpa.mpa_id = rt.mpa_id WHERE rt.severity_level >= 4 AND ess.conservation_status = 'CriticallyEndangered' LIMIT 10;</code>",
            "solution": "SELECT mpa.mpa_name, ess.species_name AS endangered_species, rt.threat_type FROM MarineProtectedAreas AS mpa JOIN EndangeredSpeciesSightings AS ess ON mpa.mpa_id = ess.mpa_id JOIN RecordedThreats AS rt ON mpa.mpa_id = rt.mpa_id WHERE rt.severity_level >= 4 AND ess.conservation_status = 'CriticallyEndangered' ORDER BY mpa.mpa_name LIMIT 10;",
            "difficulty": 3,
            "points": 150,
            "timeLimit": 360,
            "timerEnabled": false,
            "successMessage": "Well done! Table aliases made that multi-join query for marine protection analysis much clearer. This helps focus conservation efforts for SDG 14.",
            "dbAlias": "marine_db",
            "validationCriteria": {
                "keywords": ["SELECT", "FROM", "MarineProtectedAreas", "AS", "mpa", "JOIN", "EndangeredSpeciesSightings", "AS", "ess", "JOIN", "RecordedThreats", "AS", "rt", "WHERE", "LIMIT"],
                "mustContainColumns": ["mpa_name", "endangered_species", "threat_type"],
                "queryStructureChecks": [
                    {"checkType": "filterLogic", "conditions": [{"column": "rt.severity_level", "operator": ">=", "expectedValue": 4}, {"column": "ess.conservation_status", "operator": "=", "expectedValue": "CriticallyEndangered"}]},
                    {"checkType": "limit", "expectedValue": 10}
                ]
            },
            "mapDetails": {
                "showOnMap": false
            },
            "nextMissionId": 106
        },
        {
            "id": 106,
            "title": "Education Investment & Outcomes (JOINs & GROUP BY for SDG 4)",
            "description": "For SDG 4 (Quality Education), let's analyze if regional investment correlates with student performance. We'll JOIN tables and use GROUP BY for aggregated insights.<br><br><strong>Part 1: Aggregating Joined Data</strong><br><br><strong>Step-by-Step Instructions:</strong><br>1. Mount <code>edu_finance_performance_db</code> (alias <code>edu_stats_db</code>).<br>2. Correlate regional education investment with average student test scores:<br><code>SELECT rei.region_name, rei.annual_investment_usd_avg, AVG(spm.avg_test_score) AS average_regional_test_score<br>FROM RegionalEducationInvestment AS rei<br>JOIN StudentPerformanceMetrics AS spm ON rei.region_id = spm.region_id<br>WHERE rei.year_recorded = 2023 AND spm.year_recorded = 2023<br>GROUP BY rei.region_name, rei.annual_investment_usd_avg<br>ORDER BY rei.annual_investment_usd_avg DESC;</code><br><br>Click <strong>GRAPH</strong>. A SCATTER PLOT is ideal here: X-axis `annual_investment_usd_avg`, Y-axis `average_regional_test_score` to spot trends.",
            "hint": "Mount `edu_stats_db`. Use query: <code>SELECT rei.region_name, rei.annual_investment_usd_avg, AVG(spm.avg_test_score) AS avg_score FROM RegionalEducationInvestment AS rei JOIN StudentPerformanceMetrics AS spm ON rei.region_id = spm.region_id WHERE rei.year_recorded = 2023 AND spm.year_recorded = 2023 GROUP BY rei.region_name, rei.annual_investment_usd_avg ORDER BY rei.annual_investment_usd_avg DESC;</code> Then use Scatter Plot.",
            "solution": "SELECT rei.region_name, rei.annual_investment_usd_avg, AVG(spm.avg_test_score) AS average_regional_test_score FROM RegionalEducationInvestment AS rei JOIN StudentPerformanceMetrics AS spm ON rei.region_id = spm.region_id WHERE rei.year_recorded = 2023 AND spm.year_recorded = 2023 GROUP BY rei.region_name, rei.annual_investment_usd_avg ORDER BY rei.annual_investment_usd_avg DESC;",
            "difficulty": 3,
            "points": 175,
            "timeLimit": 360,
            "timerEnabled": false,
            "successMessage": "Excellent! You've combined JOINs with GROUP BY and AVG to analyze the relationship between education funding and outcomes, vital for SDG 4 strategies.",
            "dbAlias": "edu_stats_db",
            "validationCriteria": {
                "keywords": ["SELECT", "AVG", "FROM", "RegionalEducationInvestment", "JOIN", "StudentPerformanceMetrics", "ON", "GROUP BY", "ORDER BY"],
                "mustContainColumns": ["region_name", "annual_investment_usd_avg", "average_regional_test_score"],
                "aggregation": true,
                "groupBy": ["region_name", "annual_investment_usd_avg"],
                "ordered": true
            },
            "mapDetails": {
                "showOnMap": false
            },
            "nextMissionId": 107
        },
        {
            "id": 107,
            "title": "Coastal City Sustainability & Marine Health (Filtered JOINs, SDGs 11 & 14)",
            "description": "Our final analytics mission! Let's explore the complex link between coastal urban development (SDG 11) and marine ecosystem health (SDG 14). We'll use advanced JOINs, filtering, and visualization.<br><br><strong>Part 1: Comprehensive Environmental Analysis</strong><br><br><strong>Step-by-Step Instructions:</strong><br>1. Mount <code>coastal_eco_impact_db</code> (alias <code>coast_health_db</code>).<br>2. Analyze relationship between city investments in 'WasteManagement' and local 'CoralReefHealthIndex':<br><code>SELECT cc.city_name, SUM(sp.investment_mio_usd) AS total_waste_mgmt_investment, AVG(mei.indicator_value) AS avg_coral_health_index<br>FROM CoastalCities AS cc<br>JOIN SustainableProjects AS sp ON cc.city_id = sp.city_id<br>JOIN MarineEcosystemIndicators AS mei ON cc.city_id = mei.city_id<br>WHERE sp.project_category = 'WasteManagement' AND mei.indicator_name = 'CoralReefHealthIndex' AND sp.year_implemented >= 2020<br>GROUP BY cc.city_name<br>HAVING COUNT(sp.project_id) >= 2  -- Cities with at least 2 waste management projects<br>ORDER BY avg_coral_health_index DESC;</code><br><br>Click <strong>GRAPH</strong>. A SCATTER PLOT or a BAR chart could effectively display `total_waste_mgmt_investment` vs. `avg_coral_health_index` for these selected cities.",
            "hint": "Mount `coast_health_db`. Use the detailed query provided. Key elements are multiple JOINs, WHERE filters for project type and indicator, GROUP BY city, and a HAVING clause. Then visualize with Scatter or Bar chart.",
            "solution": "SELECT cc.city_name, SUM(sp.investment_mio_usd) AS total_waste_mgmt_investment, AVG(mei.indicator_value) AS avg_coral_health_index FROM CoastalCities AS cc JOIN SustainableProjects AS sp ON cc.city_id = sp.city_id JOIN MarineEcosystemIndicators AS mei ON cc.city_id = mei.city_id WHERE sp.project_category = 'WasteManagement' AND mei.indicator_name = 'CoralReefHealthIndex' AND sp.year_implemented >= 2020 GROUP BY cc.city_name HAVING COUNT(sp.project_id) >= 2 ORDER BY avg_coral_health_index DESC;",
            "difficulty": 4,
            "points": 200,
            "timeLimit": 420,
            "timerEnabled": false,
            "successMessage": "Masterful! You've executed a complex multi-faceted analysis, linking urban sustainability efforts with marine health indicators. This advanced SQL skill is crucial for data-driven policies towards SDGs 11 and 14.",
            "dbAlias": "coast_health_db",
            "validationCriteria": {
                "keywords": ["SELECT", "SUM", "AVG", "FROM", "CoastalCities", "JOIN", "SustainableProjects", "ON", "JOIN", "MarineEcosystemIndicators", "ON", "WHERE", "GROUP BY", "HAVING", "ORDER BY"],
                "mustContainColumns": ["city_name", "total_waste_mgmt_investment", "avg_coral_health_index"],
                "aggregation": true,
                "groupBy": ["city_name"],
                "queryStructureChecks": [
                    {"checkType": "filterLogic", "conditions": [
                        {"column": "sp.project_category", "expectedValue": "WasteManagement"},
                        {"column": "mei.indicator_name", "expectedValue": "CoralReefHealthIndex"},
                        {"column": "sp.year_implemented", "operator": ">=", "expectedValue": 2020}
                    ]}
                ],
                "havingClauseCheck": {"aggregateFunction": "COUNT", "column": "sp.project_id", "operator": ">=", "value": 2},
                "ordered": true
            },
            "mapDetails": {
                "showOnMap": false
            }
        }
    ]
}
}